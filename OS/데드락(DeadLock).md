# 1. 데드락(DeadLock) == 교착 상태

- 프로세스가 자원을 얻지 못해서 다음 처리를 못하고 있는 상태
- 한정된 자원을 동시에 여러 곳에서 사용하려 할 때 발생

## 1-1. 데드락이 발생하는 경우

![Untitled](https://user-images.githubusercontent.com/45481007/157034336-25ff4c61-b766-4eb6-929b-20ecf457523d.png)

- 프로세스 1은 자원 1을 사용 중이며 자원 2를 필요로 하는 상태
- 프로세스 2는 자원 2를 사용 중이며 자원 1을 필요로 하는 상태
    - 프로세스 1, 프로세스 2가 각각 필요로 하는 자원이 상대방에 할당되어 있어 두 프로세스는 무한한 대기 상태에 빠지게 됨 ⇒ DeadLock
    

### [주로 교착상태에 빠지는 경우]

- 한정된 자원을 얻기 위해 둘 이상의 프로세스가 경쟁하는 상황이 발생할 때 동시에 그 자원을 사용할 수 없는 상황이라면 두 프로세스는 대기 상태로 빠지게 됨

## 1-2. 데드락 발생 조건

- ★ 다음 조건이 모두 성립해야만 데드락이 발생
1. 상호 배제(Mutual Exclusion)
    - 자원은 한 번에 한 프로세스만 사용할 수 있음
2. 점유 대기(Hold And Wait)
    - 최소한 하나의 자원을 점유하고 있고 다른 프로세스에 할당된 자원을 추가로 점유하기 위한 프로세스가 존재해야 함
3. 비선점(No Preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼았을 수 없음
4. 순환 대기(Circular Wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야함
    - 원형의 형태로 본인의 앞 순서 프로세스들이 자원을 반환하기를 대기하고 있어야함
    

## 1-3. 데드락의 처리

### 1-3-1. 예방

- 데드락의 발생 조건 중 하나를 제거하여 해결 → 자원의 낭비가 심함
- 상호 배제 부정
    - 여러 프로세스가 자원을 공유하여 사용
- 점유 대기 부정
    - 프로세스의 실행 전에 필요한 모든 자원을 할당하고 실행
- 비선점 부전
    - 자원을 사용중인 프로세스에게 다른 프로세스에서 요청이 들어오면 점유중인 자원을 반납
- 순환 대기 부전
    - 자원에 고유번호를 할당하고 순서대로 자원을 요구

### 1-3-2. 회피

- 교착 상태 발생 시 피해가는 방법
- 은행원 알고리즘(Banker Algorithm)
    - 은행에서는 모든 고객의 요구를 충족할 수 있도록 현금을 미리 가져다 놓은 것에서 유래
    - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 다른 요구가 들어올 때 교착 상태에 빠지지 않는지 사전에 검사하여 교착 상태 회피
    - 괜찮은 상태면 자원 할당, 아니면 다른 프로세스들의 자원 반납까지 대기

### 1-3-3. 교착 상태를 탐지 & 회복

- 교착 상태가 발생한 뒤에 회복하는 방법
- 탐지(Detection)
    - 자원 할당 그래프를 통해 교착 상태를 탐지
    - 자원을 요청할 때마다 교착 상태를 탐지하므로 오버헤드가 발생
- 회복(Recovery)
    - 교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 강제 해제시킴
        - 프로세스의 종료
            - 교착 상태의 프로세스 모두 종료
            - 교착 상태가 제거될 때까지 프로세스 하나씩 종료
        - 자원 선점 방법
            - 교착 상태의 프로세스가 점유하고 있는 자원을 뺐어 다른 프로세스에게 할당(뺐긴 프로세스는 일시 정지)
            - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 자원 선점

## 자주 물어보는 질문

1. 데드락은 무엇이고 발생 조건은 무엇인가요?
2. 회피 기법 중 은행원 알고리즘은 뭔가요?
3. 기아 상태를 설명하는 식사하는 철학자 문제에 대해 설명하시오.
    - 문제
        1. 왼쪽 젓가락부터 집어든다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 생각하며 대기한다.
        2. 왼쪽을 들었으면 오른쪽 젓가락을 든다. 들 수 없다면 1번과 마찬가지로 들 수 있을 때까지 생각하며 대기한다.
        3. 두 젓가락을 모두 들었다면 일정 시간동안 식사를 한다.
        4. 식사를 마쳤으면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓는다.
        5. 다시 생각하다가 배고프면 1번으로 돌아간다.
        
    - 해결책
        1. N명이 앉을 수 있는 테이블에 철학자를 (N-1)명만 앉힘
        2. 한 철학자가 양 쪽 젓가락을 모두 잡을 수 있는 상황에서만 젓가락 집도록 허용
        3. 누군가는 오른쪽 젓가락부터 집도록 허용

### [출처]

- [https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Operating System/DeadLock.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md)
