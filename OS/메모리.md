# 메모리

메모리는 각자의 주소를 가진 대용량의 바이트 배열과도 같음

**연산-실행 순환 과정**

1. 연산이 메모리로부터 fetch
2. 해당 연산은 decode 되어 다른 피연산자를 메모리로 부터 fetch 할 수도 있음.
3. 연산이 피연산자에 대해 실행되면, 결과는 다시 메모리에 저장

CPU는 메인 메모리와 프로세서 자체에 내장된 레지스터에만 직접 접근 가능

따라서 프로그램이 실행되려면 메모리에 올라와 있어야 함

**캐시**

주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치

CPU와 메모리 사이에 속도가 빠른 메모리

**캐시가 필요한 이유**

CPU는 메모리 접근에 많은 CPU clock이 필요로 할 수 있다. 이러한 상황에서 필요한 데이터가 없는 프로세서들은 실행 중인 연산을 완료할 수 없기 때문에, 일반적으로 정지하는데 메모리 접근 빈도가 매우 높기 때문에 어느 순간 정지 시간을 더 이상 견딜 수 없게 될 것이다.

**데이터의 지역성**

캐시메모리는 데이터의 지역성의 원리를 사용, 데이터의 지역성은 시간 지역성과 공간 지역성으로 나뉜다.

시간 지역성이란 for나 while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다는 것이고, 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다.

**Base & Limit 레지스터**

![Untitled](https://user-images.githubusercontent.com/55469012/158126608-bc9b7226-d125-4417-8b92-6267822d4b99.png)

프로세스가 접근 할 수 있는 유효한 메모리 주소의 범위를 base,limit 두 레지스터를 통해 제공할 수 있다.

![Untitled 1](https://user-images.githubusercontent.com/55469012/158126506-289d0d6a-2a05-4cc4-843d-d1dee7377073.png)

두 레지스터를 통해 부적절한 메모리 접근을 막는 과정 이 과정을 통해 허가되지 않은 메모리 영역의 코드나 데이터 구조를 수정할 수 없도록 함

Base, Limt 레지스터들은 운영체제에 의해서만 값을 변경할 수 있다. 따라서 사용자 프로그램은 레지스터의 값을 변경할 수 없다.

**MMU (Memory Management Unit)**

실행시간동안 **가상 주소를 물리적 주소로 변환해주는 하드웨어**

![Untitled 2](https://user-images.githubusercontent.com/55469012/158126708-0d3d5fcf-116f-4885-8fa6-5e9af18957ee.png)

사용자 프로세스에 의해 생성되는 모든 주소들에 Relocation 레지스터의 값을 더해 실제 메모리 주소를 구한다.

그림에서 **사용자 프로그램은 절대 실제 메모리 주소를 확인할 수 없다.** 단지 346의 포인터를 생성하여 사용할 뿐이다. 사용자 프로그램에서 메모리는 346이라는 논리적 주소를 통해서만 사용된다.

논리적 주소가 0 ~ max라면, 물리적 주소는 R ~ R + max의 값을 갖게 되는 것이다. (R은 Base Register의 값이다.)

**논리적 주소는 반드시 사용되기 전에 물리적 주소로 변환되어야 한다.**
